<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Showcase Template</title><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/</link><description>Recent content on Showcase Template</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/1.-Colouring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/1.-Colouring/</guid><description>Coloring # A glsl color is defined as a vec4 variable of rgba float normalized values, i.e., each in [0.0, 1.0].
CMY and RGB Color models # The sketch below shows how to interpolate color data along a triangle primitive (which is key to tackle Mach band artifacts) and how to switch between the rgba and cmya color models. Press r to randomize the triangle and c to switch between the rgba and cmya color models:</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/2.-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/2.-Texturing/</guid><description>Texturing # A texture is an image (i.e., either a bitmap or a procedural texture) mapped onto the surface of a shape usually specified in a triangle by triangle basis.
UV Visualization # The texture is defined in the so called uv space which itself may be displayed in a variaty of ways such as the one below:
uv.js let uvShader; function preload() { // Define geometry directly in clip space (i.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/4.-Procedural-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/4.-Procedural-Texturing/</guid><description>Procedural texturing # The goal in procedural texturing is to procedurally generate a texture using an algorithm in such a way that the result can be mapped onto a shape as a texture. Procedural texturing requires the use of a frame buffer object which in p5.js is implemented as a p5.Graphics object.
The program below uses the truchet tiles implemented in the Patricio Gonzales and Jen Lowe great book of shaders to map the resulted texture onto the cylinder.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/5.-Non-Euclidean-Geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/5.-Non-Euclidean-Geometry/</guid><description>Non-Euclidean geometry # All sorts of non-euclidean geometries may be implemented by creating a link between different locations in 3D space all of which share the same viewpoint:
non_euclidean.js let easycam; let edge = 80; let fox; let foxTex; let train; let trainTex; let texShader; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(&amp;#39;/VisualComputing2022_2/sketches/Taller3/NEG/non_euclidean.frag&amp;#39;, { varyings: Tree.NONE }); fox = loadModel(&amp;#39;/VisualComputing2022_2/sketches/Taller3/NEG/fox.obj&amp;#39;, true); train = loadModel(&amp;#39;/VisualComputing2022_2/sketches/Taller3/NEG/train.</description></item></channel></rss>