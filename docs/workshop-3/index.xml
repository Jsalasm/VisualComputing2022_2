<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Showcase Template</title><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/</link><description>Recent content on Showcase Template</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/1.-Coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/1.-Coloring/</guid><description>Coloring # 1. Introducción # En este parte del taller se busca implimentar distintos modos de mezcla de colores mediante el uso de fragment shaders.
2. Revisión bibligráfica # Color blending # Existen distitas formas de realizar un color blending o mezcla de colores, los cuales son usados en distintos softwares de edición de gráficos como Adobe Photoshop.
a y b son vectores de 3 posiciones, donde cada una de estas corresponde al valor en el espacio de color RGB.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/2.-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/2.-Texturing/</guid><description>Texturing # Una textura es una imagen (es decir, un mapa de bits o una procedural) mapeada en la superficie de una figura usualmente en un triángulo o basado en ello.
UV Visualization # uv.js let uvShader; function preload() { // Define geometry directly in clip space (i.e., matrices: Tree.NONE). // Interpolate only texture coordinates (i.e., varyings: Tree.texcoords2). // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(&amp;#39;/VisualComputing2022_2/sketches/Taller3/Texturing/uv.frag&amp;#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { // shaders require WEBGL mode to work createCanvas(300, 300, WEBGL); noStroke(); // see: https://p5js.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/3.-Image-processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/3.-Image-processing/</guid><description>Image processing # 1. Introducción # En este parte del taller se busca aplicar distintos kernels de imagén junto con varias herramientas de luminosidad o brillo de imagén, partiendo de varios conceptos que serán detallados en el siguiente punto.
2. Revisión bibliográfica # Convolución # La convolución dentro del procesamiento de imágenes, es el proceso de transformar una imagén aplicando unos valores de un kernel sobre cada píxel y sus vecinos locales.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/4.-Procedural-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/4.-Procedural-Texturing/</guid><description>Procedural texturing # Una textura procedural es una textura creada utilizando una descripción matemática (es decir, un algoritmo) en lugar de datos almacenados directamente. La ventaja de este enfoque es el bajo costo de almacenamiento, la resolución ilimitada de texturas y el fácil mapeo de texturas. Este tipo de texturas se utilizan a menudo para modelar superficies o representaciones volumétricas de elementos naturales como madera, mármol, granito, metal, piedra y otros.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/5.-Non-Euclidean-Geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/5.-Non-Euclidean-Geometry/</guid><description>Non-Euclidean geometry # Resulta que no todo vive en un mundo plano bidimensional y, por lo tanto, no todo está sujeto a las leyes de la geometría euclidiana plana. Por ejemplo: tú, yo y toda la humanidad vivimos en la superficie de la Tierra, y la Tierra no es plana. Es, de hecho, un objeto aproximadamente esférico. Lo que significa que las reglas de la geometría plana no rigen nuestras vidas.</description></item><item><title/><link>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/6.-Ripple-Effect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jsalasm.github.io/VisualComputing2022_2/docs/workshop-3/6.-Ripple-Effect/</guid><description>Ripple Effect # 1. Revisión bibliográfica # Dentro de la literatura se encuentran varias implementaciones para producir el efecto de onda, sin embargo para este trabajo, se decidio utilizar la implementacion de Hugo Elias. La cual consiste en el uso de dos buffers, los cuales se encargaran de guardar el estado actual y el estado del ciclo anterior del arreglo de pixeles.
Por cada iteracion del ciclo, se calcula el valor de cada pixel, sumando el valor de sus pixeles vecinos en el ciclo anterior y dividiendolo entre dos, luego se le resta el valor del pixel actual en el buffer actual, y se le multiplica por un factor de amortiguacion.</description></item></channel></rss>